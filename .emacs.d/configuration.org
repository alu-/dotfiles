#+TITLE: Emacs configuration
#+AUTHOR: Mostly angrybacon, with modifications by alu
#+DESCRIPTION: See https://raw.githubusercontent.com/angrybacon/dotemacs/master/dotemacs.org

* Table of Content                                                      :TOC:
- [[#bootstrap][Bootstrap]]
  - [[#use-better-defaults][Use better defaults]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
- [[#theme][Theme]]
- [[#languages][Languages]]
  - [[#css][CSS]]
  - [[#csv][CSV]]
  - [[#docker][Docker]]
  - [[#html][HTML]]
  - [[#javascript][JavaScript]]
  - [[#lisp][Lisp]]
  - [[#markdown][Markdown]]
  - [[#org][Org]]
  - [[#python][Python]]
  - [[#yaml][YAML]]
- [[#features][Features]]
  - [[#alert][Alert]]
  - [[#auto-completion][Auto-Completion]]
  - [[#buffers-and-windows][Buffers and Windows]]
  - [[#comments][Comments]]
  - [[#customization-menus][Customization Menus]]
  - [[#daemon][Daemon]]
  - [[#dictionary][Dictionary]]
  - [[#diff][Diff]]
  - [[#dired][Dired]]
  - [[#expand][Expand]]
  - [[#helm][Helm]]
  - [[#helm-plugins][Helm Plugins]]
  - [[#help][Help]]
  - [[#hydra][Hydra]]
  - [[#linters][Linters]]
  - [[#mode-line][Mode-Line]]
  - [[#navigation][Navigation]]
  - [[#os-specific][OS-Specific]]
  - [[#parentheses][Parentheses]]
  - [[#paste][Paste]]
  - [[#point-and-region][Point and Region]]
  - [[#projectile][Projectile]]
  - [[#quality-of-life][Quality of Life]]
  - [[#shell-and-terminal][Shell and Terminal]]
  - [[#version-control][Version Control]]
  - [[#whitespaces][Whitespaces]]
- [[#alu][alu]]
  - [[#fixes][fixes]]
  - [[#keybindings][keybindings]]
  - [[#packages][packages]]
  - [[#hooks][hooks]]

* Bootstrap

** Use better defaults

Some UI elements are rather invasive. No-mouse master race.

#+BEGIN_SRC emacs-lisp
(when window-system
  (blink-cursor-mode 0)                           ; Disable the cursor blinking
  (scroll-bar-mode 0)                             ; Disable the scroll bar
  (tool-bar-mode 0)                               ; Disable the tool bar
  (tooltip-mode 0))                               ; Disable the tooltips
#+END_SRC

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept                   ; Silence warnings for redefinition
 auto-window-vscroll nil                          ; Lighten vertical scroll
 confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
 delete-by-moving-to-trash t                      ; Delete files to trash
 display-time-default-load-average nil            ; Don't display load average
 display-time-format "%H:%M"                      ; Format the time string
 fill-column 80                                   ; Set width for automatic line breaks
 help-window-select t                             ; Focus new help windows when opened
 indent-tabs-mode nil                             ; Stop using tabs to indent
 inhibit-startup-screen t                         ; Disable start-up screen
 initial-scratch-message ""                       ; Empty the initial *scratch* buffer
 mouse-yank-at-point t                            ; Yank at point rather than pointer
 ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
 recenter-positions '(5 top bottom)               ; Set re-centering positions
 scroll-conservatively most-positive-fixnum       ; Always scroll by one line
 scroll-margin 10                                 ; Add a margin when scrolling vertically
 select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                    ; End a sentence after a dot and a space
 show-trailing-whitespace nil                     ; Display trailing whitespaces
 split-height-threshold nil                       ; Disable vertical window splitting
 split-width-threshold nil                        ; Disable horizontal window splitting
 tab-width 4                                      ; Set width for tabs
 uniquify-buffer-name-style 'forward              ; Uniquify buffer names
 window-combination-resize t                      ; Resize windows proportionally
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width
(delete-selection-mode 1)                         ; Replace region when inserting text
(display-time-mode 1)                             ; Enable time in the mode-line
(fringe-mode 0)                                   ; Disable fringes
(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
(global-subword-mode 1)                           ; Iterate through CamelCase words
(menu-bar-mode 0)                                 ; Disable the menu bar
(mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)              ; Enable downcase-region
(put 'upcase-region 'disabled nil)                ; Enable upcase-region
(set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs. It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself. By default, changes in the customization will be
automatically detected and appended at the end of the configuration file,
=init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up. The
following tells Emacs to add extra code in another file that would be then
loaded, if existing.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=. This is also where you want your API tokens to live.

#+BEGIN_SRC emacs-lisp
(defvar me/font-family            "Inconsolata"  "The font to use.")
(defvar me/font-size-default      90        "The font size to use for default text.")
(defvar me/font-size-header-line  100        "The font size to use for the header-line.")
(defvar me/font-size-mode-line    90        "The font size to use for the mode-line.")
(defvar me/font-size-small        80        "The font size to use for smaller text.")
(defvar me/font-size-title        120        "The font size to use for titles.")

(let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
  (when (file-exists-p secret.el)
    (load secret.el)))
#+END_SRC

* Theme

Load theme and fix some high-level faces to match my personal preferences.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :demand t
  :custom
  (doom-themes-enable-bold nil)
  :config
  (load-theme 'doom-one t)
  (with-eval-after-load 'flycheck
    (set-face-attribute 'flycheck-error nil :underline `(:color ,(doom-color 'error) :style line))
    (set-face-attribute 'flycheck-info nil :underline `(:color ,(doom-color 'highlight) :style line))
    (set-face-attribute 'flycheck-warning nil :underline `(:color ,(doom-color 'warning) :style line)))
  (with-eval-after-load 'helm-buffers
    (set-face-attribute 'helm-buffer-directory nil
                        :background 'unspecified
                        :foreground 'unspecified
                        :inherit 'dired-directory)
    (set-face-attribute 'helm-buffer-file nil :inherit 'unspecified)
    (set-face-attribute 'helm-buffer-modified nil :foreground (doom-color 'orange) :inherit 'unspecified)
    (set-face-attribute 'helm-buffer-not-saved nil :foreground (doom-color 'red) :inherit 'unspecified)
    (set-face-attribute 'helm-non-file-buffer nil :inherit 'font-lock-comment-face))
  (with-eval-after-load 'helm-command
    (set-face-attribute 'helm-M-x-key nil :foreground (doom-color 'yellow) :underline 'unspecified))
  (with-eval-after-load 'helm-files
    (set-face-attribute 'helm-ff-directory nil
                        :background 'unspecified
                        :foreground 'unspecified
                        :inherit 'dired-directory))
  (with-eval-after-load 'isearch
    (set-face-attribute 'isearch nil :background (doom-color 'blue) :foreground (doom-color 'dark-blue))
    (set-face-attribute 'lazy-highlight nil :foreground (doom-color 'blue)))
  (with-eval-after-load 'faces
    (set-face-attribute 'default nil :font me/font-family :height me/font-size-default)
    (set-face-attribute 'header-line nil :box `(:color ,(doom-color 'modeline-bg) :line-width 7))
    (set-face-attribute 'help-argument-name nil :foreground (doom-color 'yellow))
    (set-face-attribute 'mode-line nil :height me/font-size-mode-line)
    (set-face-attribute 'variable-pitch nil :family 'unspecified))
  (with-eval-after-load 'font-lock
    (set-face-attribute 'font-lock-doc-face nil :italic t))
  (with-eval-after-load 'helm
    (set-face-attribute 'helm-source-header nil :background 'unspecified))
  (with-eval-after-load 'markdown
    (set-face-attribute 'markdown-table-face nil :height me/font-size-small))
  (with-eval-after-load 'outline
    (set-face-attribute 'outline-1 nil :background 'unspecified))
  (with-eval-after-load 'magit-diff
    (set-face-attribute 'magit-diff-added nil :background 'unspecified)
    (set-face-attribute 'magit-diff-hunk-region nil :inherit 'region)
    (set-face-attribute 'magit-diff-removed nil :background 'unspecified)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package mdi :load-path "lisp/mdi/")
#+END_SRC

* Languages

** CSS

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :ensure nil
  :custom (css-indent-offset 2))

(use-package scss-mode
  :ensure nil
  :preface
  (defun me/scss-set-comment-style ()
    (setq-local comment-end "")
    (setq-local comment-start "//"))
  :mode ("\\.sass\\'" "\\.scss\\'")
  :hook (scss-mode . me/scss-set-comment-style))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :config (setq-default csv-align-padding 2))
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode :mode "Dockerfile\\'")
#+END_SRC

** HTML

HTML mode is defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :ensure nil
  :preface
  (defun me/html-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((html-mode . me/html-set-pretty-print-function)
   (html-mode . sgml-electric-tag-pair-mode)
   (html-mode . sgml-name-8bit-mode)
   (html-mode . toggle-truncate-lines))
  :custom
  (sgml-basic-offset 2))
#+END_SRC

** JavaScript

- *TOFIX*: Indent level is broken
           (https://github.com/joshwnj/json-mode/issues/32).

#+BEGIN_SRC emacs-lisp
(use-package js
  :ensure nil
  :preface
  (defun me/js-prettify-symbols-mode-on ()
    (add-to-list 'prettify-symbols-alist '("function" . ?\u0192))
    (prettify-symbols-mode 1))
  :hook
  (js-mode . me/js-prettify-symbols-mode-on)
  :custom
  (js-indent-level 2))

(use-package js-doc)

(use-package js2-mode
  :ensure nil
  :bind (:map js2-mode-map ([remap comment-indent-new-line] . js2-line-break))
  :custom
  (js2-idle-timer-delay 0)
  (js2-mode-show-parse-errors nil)
  (js2-mode-show-strict-warnings nil))

(use-package json-mode
  :mode "\\.json\\'"
  :preface
  (defun me/json-set-indent-level ()
    (setq-local js-indent-level 2))
  :hook (json-mode . me/json-set-indent-level))

(use-package rjsx-mode
  :preface
  (defun me/rjsx-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-rjsx/body))
  (defun me/rjsx-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
  :hook
  ((rjsx-mode . me/aggressive-indent-mode-off)
   (rjsx-mode . me/rjsx-set-ongoing-hydra-body)
   (rjsx-mode . me/rjsx-set-pretty-print-function)
   (rjsx-mode . sgml-electric-tag-pair-mode)
   (rjsx-mode . turn-off-auto-fill)))

(use-package web-mode
  :custom (web-mode-enable-auto-indentation nil))
#+END_SRC

** Lisp

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :ensure nil
  :hook (ielm-mode . (lambda () (setq-local scroll-margin 0))))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :preface
  (defun me/markdown-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-markdown/body))
  :mode
  ("INSTALL\\'"
   "CONTRIBUTORS\\'"
   "LICENSE\\'"
   "README\\'"
   "\\.markdown\\'"
   "\\.md\\'")
  :hook
  (markdown-mode . me/markdown-set-ongoing-hydra-body)
  :custom
  (markdown-asymmetric-header t)
  (markdown-split-window-direction 'right)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map))
#+END_SRC

** Org

This very file is organized with =org-mode=. I am definitely not a power user of
Org, but I'm getting there. :-)

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :preface
  (defun me/org-src-buffer-name (org-buffer-name language)
    "Construct the buffer name for a source editing buffer. See
`org-src--construct-edit-buffer-name'."
    (format "*%s*" org-buffer-name))
  (defun me/org-set-ongoing-hydra-body ()
    (setq me/ongoing-hydra-body #'hydra-org/body))
  :bind
  (:map org-mode-map
        ([remap backward-paragraph] . me/backward-paragraph-dwim)
        ([remap forward-paragraph] . me/forward-paragraph-dwim)
        ("<C-return>" . nil)
        ("<C-S-down>" . nil)
        ("<C-S-up>" . nil)
        ("<M-S-down>" . nil)
        ("<M-S-up>" . nil))
  :hook
  ((org-mode . me/org-set-ongoing-hydra-body)
   (org-mode . org-sticky-header-mode)
   (org-mode . toc-org-enable))
  :custom
  (org-descriptive-links nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-src-window-setup 'current-window)
  (org-startup-folded nil)
  (org-startup-truncated nil)
  (org-support-shift-select 'always)
  :config
  (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer-name))
#+END_SRC

Display the current Org header in the header-line.

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :custom
  (org-sticky-header-full-path 'full)
  (org-sticky-header-outline-path-separator " / ")
  :config
  (setq-default
   org-sticky-header-header-line-format
   '(:eval (setq org-sticky-header-stickyline (concat " " (org-sticky-header--fetch-stickyline))))))
#+END_SRC

Tired of having to manually update your tables of contents? This package will
maintain a TOC at the first heading that has a =:TOC:= tag.

#+BEGIN_SRC emacs-lisp
(use-package toc-org :after org)
#+END_SRC

** Python

- *TODO*: Fix for =ipython= 5.1.0.

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure nil
  :hook (python-mode . turn-on-prettify-symbols-mode)
  :config
  (when (executable-find "ipython3")
    (setq-default
     python-shell-interpreter "ipython3"
     python-shell-interpreter-args "--colors=Linux --profile=default --simple-prompt"
     python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
     python-shell-prompt-regexp "In \\[[0-9]+\\]: "
     python-shell-completion-setup-code
     "from IPython.core.completerlib import module_completion"
     python-shell-completion-module-string-code
     "';'.join(module_completion('''%s'''))\n"
     python-shell-completion-string-code
     "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode :mode "\\.yml\\'")
#+END_SRC

* Features
** Alert

#+BEGIN_QUOTE
Alert is a Growl-workalike for Emacs which uses a common notification interface
and multiple, selectable "styles", whose use is fully customizable by the user.

[[https://github.com/jwiegley/alert][John Wiegley]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package alert
  :config
  (when (eq system-type 'darwin)
    (setq-default alert-default-style 'osx-notifier)))
#+END_SRC

** Auto-Completion

Auto-completion at point. Display a small pop-in containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package company
  :bind
  (:map company-active-map
        ("RET" . nil)
        ([return] . nil)
        ("TAB" . company-complete-selection)
        ([tab] . company-complete-selection)
        ("<right>" . company-complete-common))
  :hook
  (after-init . global-company-mode)
  :custom
  (company-dabbrev-downcase nil)
  (company-idle-delay .2)
  (company-minimum-prefix-length 1)
  (company-require-match nil)
  (company-tooltip-align-annotations t))
#+END_SRC


** Buffers and Windows

Allow repeated use of =←= and =→= when using =previous-buffer= and
=next-buffer=.

- *TODO*: Make a hydra.

#+BEGIN_SRC emacs-lisp
(defun me/switch-to-buffer-continue ()
  "Activate a sparse keymap:
  <left>   `previous-buffer'
  <right>  `next-buffer'"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<left>") #'previous-buffer)
     (define-key map (kbd "<right>") #'next-buffer)
     map)))
(advice-add 'previous-buffer :after #'me/switch-to-buffer-continue)
(advice-add 'next-buffer :after #'me/switch-to-buffer-continue)
#+END_SRC

Window management.

- *TODO*: Shackle Magit.

#+BEGIN_QUOTE
=shackle= gives you the means to put an end to popped up buffers not behaving they
way you'd like them to. By setting up simple rules you can for instance make
Emacs always select help buffers for you or make everything reuse your currently
selected window.

[[https://github.com/wasamasa/shackle][Vasilij Schneidermann]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :hook
  (after-init . shackle-mode)
  :custom
  (shackle-rules '((help-mode :inhibit-window-quit t :same t)))
  (shackle-select-reused-windows t))
#+END_SRC

Bind commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-M-<left>". windmove-left)
   ("C-M-<right>". windmove-right)
   ("C-M-<up>". windmove-up)
   ("C-M-<down>". windmove-down)))
#+END_SRC

Allow undo's and redo's with window configurations.

#+BEGIN_QUOTE
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the
changes can be "undone" using the command =winner-undo=.  By default this one is
bound to the key sequence ctrl-c left.  If you change your mind (while undoing),
you can press ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :hook (after-init . winner-mode))
#+END_SRC

** Comments

#+BEGIN_SRC emacs-lisp
(use-package newcomment
  :ensure nil
  :bind
  ("<M-return>" . comment-indent-new-line)
  :custom
  (comment-auto-fill-only-comments t)
  (comment-multi-line t))
#+END_SRC

** Customization Menus

This merely changes face attributes. It also /Zenburn/ customization buffers a
little more.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom (custom-unlispify-tag-names nil))
#+END_SRC

** Daemon

Emacs can be run as a daemon onto which Emacs clients can latch on. This allows
for much shorter starting times when you already got Emacs running ie. when you
want to edit a single file for a quick edit.

#+BEGIN_SRC emacs-lisp
(use-package server
  :ensure nil
  :hook (after-init . server-start))
#+END_SRC

** Dictionary

Define words using Wordnik.

#+BEGIN_SRC emacs-lisp
(use-package define-word)
#+END_SRC

Translate using Google.

#+BEGIN_SRC emacs-lisp
(use-package google-translate)
#+END_SRC

** Diff

Ediff is a visual interface to Unix =diff=.

#+BEGIN_SRC emacs-lisp
(use-package ediff-wind
  :ensure nil
  :custom
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** Dired

Configure Dired buffers. Amongst many other things, Emacs is also a file
explorer.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :preface
  (defun me/dired-directories-first ()
    "Sort dired listings with directories first before adding marks."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2)
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))
  :hook
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-alh")
  (dired-ls-F-marks-symlinks nil)
  (dired-recursive-copies 'always)
  :config
  (advice-add 'dired-readin :after #'me/dired-directories-first))
#+END_SRC

** Expand

HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've
gathered all features that look anywhere close to this behavior for it to handle
under the same bind, that is =<C-return>=. Basically it's an expand DWIM.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil))
  :hook
  (css-mode html-mode rjsx-mode)
  :custom
  (emmet-insert-flash-time .1)
  (emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun me/emmet-try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args)))
  :bind
  ("<C-return>" . hippie-expand)
  :custom
  (hippie-expand-try-functions-list '(yas-hippie-try-expand me/emmet-try-expand-line))
  (hippie-expand-verbose nil))

(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
        ("TAB" . nil)
        ([tab] . nil))
  :hook
  ((emacs-lisp-mode . yas-minor-mode)
   (html-mode . yas-minor-mode)
   (js-mode . yas-minor-mode)
   (org-mode . yas-minor-mode)
   (python-mode . yas-minor-mode))
  :custom
  (yas-snippet-dirs `(,(expand-file-name "snippets/" user-emacs-directory)))
  (yas-verbosity 2)
  :config
  (yas-reload-all))
#+END_SRC

** Helm

Helm is a beast. Although heavily, it replaces =ido-mode= in many ways.

#+BEGIN_QUOTE
=Helm= is an Emacs framework for incremental completions and narrowing
selections. It helps to rapidly complete file names, buffer names, or any other
Emacs interactions requiring selecting an item from a list of possible choices.

Helm is a fork of =anything.el=, which was originally written by Tamas Patrovic
and can be considered to be its successor. =Helm= cleans the legacy code that is
leaner, modular, and unchained from constraints of backward compatibility.

[[https://github.com/emacs-helm/helm][Bozhidar Batsov]]
#+END_QUOTE


- *TODO*: Hide the buffer size column.
- *TODO*: Test =me/helm-pulse-follow= on MacOS. Is it Windows that makes it ugly?
- *TOFIX*: Help buffer resizes the frame.
- *TOFIX*: The recentering is too aggressive.
- *TOFIX*: Fix =me/helm-grab-candidates=.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :preface
  (defun me/helm-focus-follow ()
    ;; (let ((point (point)))
    ;;   (when (and (pulse-available-p) (> point 1))
    ;;     (pulse-momentary-highlight-one-line point)))
    (recenter-top-bottom (car recenter-positions)))
  (defun me/helm-grab-candidates (beg end)
    (interactive "r")
    (if (region-active-p)
        (kill-ring-save beg end)
      (with-helm-buffer (kill-ring-save (point-min) (point-max)))))
  :bind
  (([remap execute-extended-command] . helm-M-x)
   ([remap find-file] . helm-find-files)
   ([remap switch-to-buffer] . helm-buffers-list)
   :map helm-map
   ("<left>" . backward-char)
   ("<right>" . forward-char)
   ("M-w" . me/helm-grab-candidates))
  :hook
  (after-init . helm-mode)
  (helm-after-action . me/helm-focus-follow)
  :custom
  (helm-M-x-fuzzy-match t)
  (helm-always-two-windows t)
  (helm-buffer-max-length nil)
  (helm-buffers-fuzzy-matching t)
  (helm-completion-in-region-fuzzy-match t)
  (helm-display-header-line nil)
  (helm-ff-no-preselect t)
  (helm-ff-skip-boring-files t)
  (helm-find-file-ignore-thing-at-point t)
  (helm-help-full-frame nil)
  (helm-mode-fuzzy-match t)
  (helm-net-prefer-curl (if (executable-find "curl") t nil))
  (helm-org-headings-fontify t)
  (helm-scroll-amount 5)
  (helm-split-window-default-side 'left)
  (helm-truncate-lines t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package helm-imenu
  :ensure nil
  :bind
  (:map helm-imenu-map
        ("<left>" . backward-char)
        ("<right>" . forward-char)))
#+END_SRC

** Helm Plugins

Fourth-party packages for Helm.

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :bind
  (:map helm-ag-map
        ("<left>" . backward-char)
        ("<right>" . forward-char))
  :custom
  (helm-ag-show-status-function nil))

(use-package helm-descbinds
  :bind
  ([remap describe-bindings] . helm-descbinds)
  :custom
  (helm-descbinds-window-style 'split-window))

(use-package helm-describe-modes
  :bind ([remap describe-mode] . helm-describe-modes))

(use-package helm-org
  :commands helm-org-in-buffer-headings)

(use-package helm-projectile
  :defer nil
  :bind
  (:map helm-projectile-find-file-map
        ("<left>" . backward-char)
        ("<right>" . forward-char))
  :config
  (helm-projectile-toggle 1))
#+END_SRC

** Help

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Hydra

Hydra allows me to group binds together. It also shows a list of all implemented
commands in the echo area.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

[[https://github.com/abo-abo/hydra][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :preface
  (defvar-local me/ongoing-hydra-body nil)
  (defun me/ongoing-hydra ()
    (interactive)
    (if me/ongoing-hydra-body
        (funcall me/ongoing-hydra-body)
      (user-error "me/ongoing-hydra: me/ongoing-hydra-body is not set")))
  :bind
  ("C-c d" . hydra-dates/body)
  ("C-c f" . hydra-flycheck/body)
  ("C-c g" . hydra-magit/body)
  ("C-c h" . hydra-helm/body)
  ("C-c o" . me/ongoing-hydra)
  ("C-c p" . hydra-projectile/body)
  ("C-c s" . hydra-system/body)
  ("C-c w" . hydra-windows/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

*** Hydra / Dates

Group date-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color blue)
  "
^
^Dates^             ^Insert^            ^Insert with Time^
^─────^─────────────^──────^────────────^────────────────^──
_q_ quit            _d_ short           _D_ short
^^                  _i_ iso             _I_ iso
^^                  _l_ long            _L_ long
^^                  ^^                  ^^
"
  ("q" nil)
  ("d" me/date-short)
  ("D" me/date-short-with-time)
  ("i" me/date-iso)
  ("I" me/date-iso-with-time)
  ("l" me/date-long)
  ("L" me/date-long-with-time))
#+END_SRC

[[./screenshots/hydra.dates.png]]

*** Hydra / Flycheck

Group Flycheck commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck (:color blue)
  "
^
^Flycheck^          ^Errors^            ^Checker^
^────────^──────────^──────^────────────^───────^───────────
_q_ quit            _<_ previous        _?_ describe
_m_ manual          _>_ next            _d_ disable
_v_ verify setup    _f_ check           _s_ select
^^                  _l_ list            ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-manual)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))
#+END_SRC

[[./screenshots/hydra.flycheck.png]]

*** Hydra / Helm

Group Helm commands.

- *TODO*: Make =helm-mdi=.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:color blue)
  "
^
^Helm^              ^Browse^
^────^──────────────^──────^────────────
_q_ quit            _c_ colors
_r_ resume          _g_ google
^^                  _i_ imenu
^^                  _k_ kill-ring
^^                  ^^
"
  ("q" nil)
  ("c" helm-colors)
  ("g" helm-google-suggest)
  ("i" helm-imenu)
  ("k" helm-show-kill-ring)
  ("r" helm-resume))
#+END_SRC

[[./screenshots/hydra.helm.png]]

*** Hydra / Magit

Group Magit commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-magit (:color blue)
  "
^
^Magit^             ^Do^
^─────^─────────────^──^────────────────
_q_ quit            _b_ blame
^^                  _c_ clone
^^                  _i_ init
^^                  _s_ status
^^                  ^^
"
  ("q" nil)
  ("b" magit-blame)
  ("c" magit-clone)
  ("i" magit-init)
  ("s" magit-status))
#+END_SRC

[[./screenshots/hydra.magit.png]]

*** Hydra / Markdown

Group Markdown commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-markdown (:color pink)
  "
^
^Markdown^          ^Table Columns^     ^Table Rows^
^────────^──────────^─────────────^─────^──────────^────────
_q_ quit            _c_ insert          _r_ insert
^^                  _C_ delete          _R_ delete
^^                  _M-<left>_ left     _M-<down>_ down
^^                  _M-<right>_ right   _M-<up>_ up
^^                  ^^                  ^^
"
  ("q" nil)
  ("c" markdown-table-insert-column)
  ("C" markdown-table-delete-column)
  ("r" markdown-table-insert-row)
  ("R" markdown-table-delete-row)
  ("M-<left>" markdown-table-move-column-left)
  ("M-<right>" markdown-table-move-column-right)
  ("M-<down>" markdown-table-move-row-down)
  ("M-<up>" markdown-table-move-row-up))
#+END_SRC

[[./screenshots/hydra.markdown.png]]

*** Hydra / Org

Group Org commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color pink)
  "
^
^Org^               ^Links^             ^Outline^
^───^───────────────^─────^─────────────^───────^───────────
_q_ quit            _i_ insert          _<_ previous
^^                  _n_ next            _>_ next
^^                  _p_ previous        _a_ all
^^                  _s_ store           _o_ goto
^^                  ^^                  _v_ overview
^^                  ^^                  ^^
"
  ("q" nil)
  ("<" org-backward-element)
  (">" org-forward-element)
  ("a" outline-show-all)
  ("i" org-insert-link :color blue)
  ("n" org-next-link)
  ("o" helm-org-in-buffer-headings :color blue)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
#+END_SRC

[[./screenshots/hydra.org.png]]

*** Hydra / Projectile

Group Projectile commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-projectile (:color blue)
  "
^
^Projectile^        ^Buffers^           ^Find^              ^Search^
^──────────^────────^───────^───────────^────^──────────────^──────^────────────
_q_ quit            _b_ list            _d_ directory       _r_ replace
_i_ reset cache     _K_ kill all        _D_ root            _R_ regexp replace
^^                  _S_ save all        _f_ file            _s_ ag
^^                  ^^                  _p_ project         ^^
^^                  ^^                  ^^                  ^^
"
  ("q" nil)
  ("b" helm-projectile-switch-to-buffer)
  ("d" helm-projectile-find-dir)
  ("D" projectile-dired)
  ("f" helm-projectile-find-file)
  ("i" projectile-invalidate-cache :color red)
  ("K" projectile-kill-buffers)
  ("p" helm-projectile-switch-project)
  ("r" projectile-replace)
  ("R" projectile-replace-regexp)
  ("s" helm-projectile-ag)
  ("S" projectile-save-project-buffers))
#+END_SRC

[[./screenshots/hydra.projectile.png]]

*** Hydra / RJSX

Group React JavaScript commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-rjsx (:color blue)
  "
^
^RJSX^              ^JSDoc^
^────^──────────────^─────^─────────────
_q_ quit            _f_ function
^^                  _F_ file
"
  ("q" nil)
  ("f" js-doc-insert-function-doc-snippet)
  ("F" js-doc-insert-file-doc))
#+END_SRC

[[./screenshots/hydra.rjsx.png]]

*** Hydra / System

Group system-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-system (:color blue)
  "
^
^System^            ^Packages^          ^Processes^         ^Shell^
^──────^────────────^────────^──────────^─────────^─────────^─────^─────────────
_q_ quit            _p_ list            _s_ list            _e_ eshell
^^                  _P_ upgrade         ^^                  _t_ term
^^                  ^^                  ^^                  _T_ ansi-term
"
  ("q" nil)
  ("e" (eshell t))
  ("p" paradox-list-packages)
  ("P" paradox-upgrade-packages)
  ("s" list-processes)
  ("t" term)
  ("T" ansi-term))
#+END_SRC

[[./screenshots/hydra.system.png]]

*** Hydra / Windows

Group window-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-windows (:color pink)
  "
^
^Windows^           ^Window^            ^Zoom^
^───────^───────────^──────^────────────^────^──────────────
_q_ quit            _b_ balance         _-_ out
^^                  _i_ heighten        _+_ in
^^                  _j_ narrow          _=_ reset
^^                  _k_ lower           ^^
^^                  _l_ widen           ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("b" balance-windows)
  ("i" enlarge-window)
  ("j" shrink-window-horizontally)
  ("k" shrink-window)
  ("l" enlarge-window-horizontally)
  ("-" text-scale-decrease)
  ("+" text-scale-increase)
  ("=" (text-scale-increase 0)))
#+END_SRC

[[./screenshots/hydra.windows.png]]


** Linters

Flycheck lints warnings and errors directly within buffers. It can check a lot
of different syntaxes, as long as you make sure that Emacs has access to the
binaries (see [[./README.org][README.org]]).

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook
  ((css-mode . flycheck-mode)
   (emacs-lisp-mode . flycheck-mode)
   (js-mode . flycheck-mode)
   (php-mode . flycheck-mode)
   (python-mode . flycheck-mode))
  :custom
  (flycheck-check-syntax-automatically '(save mode-enabled))
  (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-display-errors-delay .3))
#+END_SRC

** Mode-Line

*** Mode-Line / Screenshots

Here is how it looks:

/In an active window/

[[./screenshots/emacs.mode-line.default.png]]

/In an inactive window/

[[./screenshots/emacs.mode-line.inactive.png]]

/In a dirty buffer/

[[./screenshots/emacs.mode-line.dirty.png]]

/With unread ERC messages/

[[./screenshots/emacs.mode-line.erc.png]]

/With Flycheck errors/

[[./screenshots/emacs.mode-line.flycheck.png]]

/When inside of a Helm session/

[[./screenshots/emacs.mode-line.helm.png]]

/When using isearch/

[[./screenshots/emacs.mode-line.isearch.png]]

/With an active region/

[[./screenshots/emacs.mode-line.region.png]]

/With an active rectangle/

[[./screenshots/emacs.mode-line.rectangle.png]]

- Green means buffer is clean ie. file is saved
- Red means buffer is dirty ie. file is modified
- Blue means buffer is read-only

*** Mode-Line / Doom-Modeline

- *TOFIX*: Fix =helm-follow= segment.
- *TOFIX*: Fix =helm-prefix-argument= segment.

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :demand t
  :custom
  (doom-modeline-buffer-file-name-style 'relative-to-project)
  (doom-modeline-enable-word-count t)
  (doom-modeline-icon t)
  (doom-modeline-percent-position nil)
  :config
  (doom-modeline-def-segment me/buffer-name
    "The buffer name."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)
     (doom-modeline-spc)))
  (doom-modeline-def-segment me/buffer-position
    "The buffer position."
    (let ((active (doom-modeline--active)))
      (propertize (concat (doom-modeline-spc)
                          (format-mode-line "%l:%c")
                          (doom-modeline-spc))
                  'face (if active 'mode-line 'mode-line-inactive))))
  (doom-modeline-def-segment me/helm-name
    "The Helm buffer name."
    (concat
     (doom-modeline-spc)
     (propertize
      (let* ((buffer (buffer-name))
             (name (cdr (assoc buffer doom-modeline--helm-buffer-ids)))
             (result (cond ((functionp name) (funcall name))
                           ((stringp name) name)
                           (t (string-match "\\*helm:? \\(mode \\)?\\([^\\*]+\\)\\*" buffer)
                              (s-join " " `("Helm" ,(capitalize (match-string 2 buffer))))))))
        (replace-regexp-in-string "HELM" "Helm" result t 'literal))
      'face 'doom-modeline-buffer-file)
     (doom-modeline-spc)))
  (doom-modeline-mode 1)
  (doom-modeline-def-modeline 'helm
    '(bar me/helm-name helm-follow helm-prefix-argument)
    '(helm-number))
  (doom-modeline-def-modeline 'info
    '(bar me/buffer-name info-nodes me/buffer-position selection-info)
    '(irc matches process major-mode workspace-name))
  (doom-modeline-def-modeline 'main
    '(bar me/buffer-name remote-host me/buffer-position checker selection-info)
    '(irc matches process vcs major-mode workspace-name))
  (doom-modeline-def-modeline 'project
    '(bar buffer-default-directory)
    '(irc matches process major-mode workspace-name)))
#+END_SRC

** Navigation

*** Navigation / Inline

Smarter =C-a=.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line] #'me/beginning-of-line-dwim)

(defun me/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
#+END_SRC

*** Navigation / Paragraphs

I disagree with Emacs' definition of paragraphs so I redefined the way it should
jump from one paragraph to another.

- *TOFIX*: Ignore invisible text.

#+BEGIN_SRC emacs-lisp
(global-set-key [remap backward-paragraph] #'me/backward-paragraph-dwim)
(global-set-key [remap forward-paragraph] #'me/forward-paragraph-dwim)

(defun me/backward-paragraph-dwim ()
  "Move backward to start of paragraph."
  (interactive "^")
  (skip-chars-backward "\n")
  (unless (search-backward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-min)))
  (skip-chars-forward "\n"))

(defun me/forward-paragraph-dwim ()
  "Move forward to start of next paragraph."
  (interactive "^")
  (skip-chars-forward "\n")
  (unless (search-forward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-max)))
  (skip-chars-forward "\n"))
#+END_SRC

*** Navigation / Pulse

Pulse temporarily highlights the background color of a line or region.

#+BEGIN_SRC emacs-lisp
(use-package pulse :ensure nil)
#+END_SRC

*** Navigation / Replace

Better search and replace features. Even though I prefer to use
=multiple-cursors= to replace text in different places at once, =anzu= has a
nice feedback on regexp matches.

#+BEGIN_QUOTE
=anzu.el= is an Emacs port of
[[https://github.com/osyo-manga/vim-anzu][anzu.vim]]. =anzu.el= provides a minor
mode which displays /current match/ and /total matches/ information in the
mode-line in various search modes.

[[https://github.com/syohex/emacs-anzu][Syohei Yoshida]]
#+END_QUOTE

/Regular replace/

[[./screencasts/emacs.anzu-replace.gif]]

/Regexp replace/

[[./screencasts/emacs.anzu-replace-regexp.gif]]

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind
  ([remap query-replace] . anzu-query-replace-regexp)
  :hook
  (after-init . global-anzu-mode)
  :custom
  (anzu-cons-mode-line-p nil))
#+END_SRC

*** Navigation / Scroll

Enable horizontal scroll.

- *TODO*: Scroll the window under cursor instead of where point is.

#+BEGIN_SRC emacs-lisp
(put 'scroll-left 'disabled nil)
(defun me/scroll-left ()
  (interactive)
  (when truncate-lines (scroll-left 2)))
(defun me/scroll-right ()
  (interactive)
  (when truncate-lines (scroll-right 2)))
(global-set-key (kbd "<wheel-left>") #'me/scroll-right)
(global-set-key (kbd "<wheel-right>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-down>") #'me/scroll-left)
(global-set-key (kbd "S-<wheel-up>") #'me/scroll-right)
#+END_SRC

Configure the mouse scroll.

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :ensure nil
  :custom
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(1 ((control) . 5))))
#+END_SRC

*** Navigation / Search

Isearch stands for /incremental search/. This means that search results are
highlighted while you are typing your query, incrementally. Since he who can do
more can do less, I've replaced default bindings with the regexp-equivalent
commands.

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :ensure nil
  :bind
  (("C-S-r" . isearch-backward-regexp)
   ("C-S-s" . isearch-forward-regexp)
   :map isearch-mode-map
   ("<M-down>" . isearch-ring-advance)
   ("<M-up>" . isearch-ring-retreat)
   :map minibuffer-local-isearch-map
   ("<M-down>" . next-history-element)
   ("<M-up>" . previous-history-element))
  :init
  (setq-default
   isearch-allow-scroll t
   lazy-highlight-cleanup nil
   lazy-highlight-initial-delay 0))
#+END_SRC

** OS-Specific

Augment Emacs experience for MacOS users.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   exec-path (append exec-path '("/usr/local/bin"))  ; Add Homebrew path
   ns-command-modifier 'meta                         ; Map Meta to the Cmd key
   ns-option-modifier 'super                         ; Map Super to the Alt key
   ns-right-option-modifier nil))                    ; Disable the right Alt key
#+END_SRC

Initialize environment variables.

#+BEGIN_QUOTE
Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI
inherits a default set of environment variables.

This library works solves this problem by copying important environment
variables from the user's shell: it works by asking your shell to print out the
variables of interest, then copying them into the Emacs environment.

[[https://github.com/purcell/exec-path-from-shell][Steve Purcell]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :hook (after-init . exec-path-from-shell-initialize))
#+END_SRC

** Parentheses

Highlight parenthese-like delimiters in a rainbow fashion. It ease the reading
when dealing with mismatched parentheses.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

I am still looking for the perfect parenthesis management setup as of
today... No package seem to please my person.

- *TODO*: Find a better parenthese management package.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("C-<backspace>" . sp-unwrap-sexp)
   ("C-<left>" . sp-forward-barf-sexp)
   ("C-<right>" . sp-forward-slurp-sexp)
   ("C-S-<left>" . sp-backward-slurp-sexp)
   ("C-S-<right>" . sp-backward-barf-sexp))
  :hook
  (after-init . smartparens-global-mode)
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  :config
  (show-paren-mode 0)
  (require 'smartparens-config))
#+END_SRC

** Paste

#+BEGIN_QUOTE
This mode allows to paste whole buffers or parts of buffers to pastebin-like
services. It supports more than one service and will failover if one service
fails.

[[https://github.com/etu/webpaste.el][Elis Hirwing]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package webpaste)
#+END_SRC

** Point and Region

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-+" . er/contract-region)
  ("C-=" . er/expand-region))
#+END_SRC

Persistent highlighting.

#+BEGIN_SRC emacs-lisp
(use-package highlight)
#+END_SRC

Enable multiple cursors at once. Some witchcraft at work here.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C-S-<mouse-1>" . mc/add-cursor-on-click)
   ("C-S-c C-S-a" . mc/vertical-align-with-space)
   ("C-S-c C-S-c" . mc/edit-lines)
   ("C-S-c C-S-l" . mc/insert-letters)
   ("C-S-c C-S-n" . mc/insert-numbers)
   ("C-'" . mc-hide-unmatched-lines-mode))
  :init
  (setq-default
   mc/list-file (expand-file-name ".multiple-cursors.el" user-emacs-directory))
  :custom
  (mc/edit-lines-empty-lines 'ignore)
  (mc/insert-numbers-default 1))
#+END_SRC

Enable new custom binds when region is active. I've also added a few helpers to
use with =selected=.

#+BEGIN_SRC emacs-lisp
(use-package selected
  :preface
  (defvar-local me/pretty-print-function nil)
  (defun me/pretty-print (beg end)
    (interactive "r")
    (if me/pretty-print-function
        (progn (funcall me/pretty-print-function beg end)
               (setq deactivate-mark t))
      (user-error "me/pretty-print: me/pretty-print-function is not set")))
  :bind
  (:map selected-keymap
        ("<"           . mc/mark-previous-like-this)
        (">"           . mc/mark-next-like-this)
        ("C-<tab>"     . me/pretty-print)
        ("C-<"         . mc/unmark-previous-like-this)
        ("C->"         . mc/unmark-next-like-this)
        ("C-M-<"       . mc/skip-to-previous-like-this)
        ("C-M->"       . mc/skip-to-next-like-this)
        ("C-?"         . hydra-selected/body)
        ("C-c C-c"     . me/eval-region-and-kill-mark)
        ("C-b"         . me/browse-url-and-kill-mark)
        ("C-c c"       . capitalize-region)
        ("C-c k"       . me/kebab-region)
        ("C-c l"       . downcase-region)
        ("C-c u"       . upcase-region)
        ("C-d"         . define-word-at-point)
        ("C-f"         . fill-region)
        ("C-g"         . selected-off)
        ("C-h h"       . hlt-highlight-region)
        ("C-h H"       . hlt-unhighlight-region)
        ("C-p"         . webpaste-paste-region)
        ("C-s r"       . reverse-region)
        ("C-s s"       . sort-lines)
        ("C-s w"       . me/sort-words)
        ("C-t"         . gogole-translate-at-point)
        ("<M-S-left>"  . me/indent-rigidly-left-tab-and-keep-mark)
        ("<M-S-right>" . me/indent-rigidly-right-tab-and-keep-mark))
  :hook (after-init . selected-global-mode)
  :config (require 'browse-url))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/eval-region-and-kill-mark (beg end)
  "Execute the region as Lisp code.
Call `eval-region' and kill mark. Move back to the beginning of the region."
  (interactive "r")
  (eval-region beg end)
  (setq deactivate-mark t)
  (goto-char beg))

(defun me/browse-url-and-kill-mark (url &rest args)
  "Ask a WWW browser to load URL.
Call `browse-url' and kill mark."
  (interactive (browse-url-interactive-arg "URL: "))
  (apply #'browse-url url args)
  (setq deactivate-mark t))

(defun me/indent-rigidly-left-and-keep-mark (beg end)
  "Indent all lines between BEG and END leftward by one space.
Call `indent-rigidly-left' and keep mark."
  (interactive "r")
  (indent-rigidly-left beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-left-tab-and-keep-mark (beg end)
  "Indent all lines between BEG and END leftward to a tab stop.
Call `indent-rigidly-left-to-tab-stop' and keep mark."
  (interactive "r")
  (indent-rigidly-left-to-tab-stop beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-right-and-keep-mark (beg end)
  "Indent all lines between BEG and END rightward by one space.
Call `indent-rigidly-right' and keep mark."
  (interactive "r")
  (indent-rigidly-right beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-right-tab-and-keep-mark (beg end)
  "Indent all lines between BEG and END rightward to a tab stop.
Call `indent-rigidly-right-to-tab-stop' and keep mark."
  (interactive "r")
  (indent-rigidly-right-to-tab-stop beg end)
  (setq deactivate-mark nil))

(defun me/kebab-region (begin end)
  "Convert region to kebab-case."
  (interactive "r")
  (downcase-region begin end)
  (save-excursion
    (perform-replace " +" "-" nil t nil nil nil begin end)))

(defun me/sort-words (reverse beg end)
  "Sort words in region alphabetically, in REVERSE if negative.
Prefixed with negative \\[universal-argument], sorts in reverse.

The variable `sort-fold-case' determines whether alphabetic case
affects the sort order.

See `sort-regexp-fields'."
  (interactive "*P\nr")
  (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+END_SRC

Work on lines.

- *TODO*: Handle regions.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<M-S-up>") 'me/duplicate-backward)
(global-set-key (kbd "<M-S-down>") 'me/duplicate-forward)
(global-set-key (kbd "<M-down>") 'me/swap-line-down)
(global-set-key (kbd "<M-up>") 'me/swap-line-up)

(defun me/duplicate-line (&optional stay)
  "Duplicate current line.
With optional argument STAY true, leave point where it was."
  (save-excursion
    (move-end-of-line nil)
    (save-excursion
      (insert (buffer-substring (point-at-bol) (point-at-eol))))
    (newline))
  (unless stay
    (let ((column (current-column)))
      (forward-line)
      (forward-char column))))

(defun me/duplicate-backward ()
  "Duplicate current line upward or region backward.
If region was active, keep it so that the command can be repeated."
  (interactive)
  (if (region-active-p)
      (let (deactivate-mark)
        (save-excursion
          (insert (buffer-substring (region-beginning) (region-end)))))
    (me/duplicate-line t)))

(defun me/duplicate-forward ()
  "Duplicate current line downward or region forward.
If region was active, keep it so that the command can be repeated."
  (interactive)
  (if (region-active-p)
      (let (deactivate-mark (point (point)))
        (insert (buffer-substring (region-beginning) (region-end)))
        (push-mark point))
    (me/duplicate-line)))

(defun me/swap-line-down ()
  "Move down the line under point."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))

(defun me/swap-line-up ()
  "Move up the line under point."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))
#+END_SRC

** Projectile

Projectile brings project-level facilities to Emacs such as grep, find and
replace.

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :hook
  (after-init . projectile-global-mode)
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" user-emacs-directory)
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory))
  :custom
  (projectile-completion-system 'helm)
  (projectile-enable-caching t))
#+END_SRC

** Quality of Life

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :preface
  (defun me/aggressive-indent-mode-off ()
    (aggressive-indent-mode 0))
  :hook
  ((css-mode . aggressive-indent-mode)
   (emacs-lisp-mode . aggressive-indent-mode)
   (js-mode . aggressive-indent-mode)
   (lisp-mode . aggressive-indent-mode)
   (sgml-mode . aggressive-indent-mode))
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun me/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun me/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun me/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun me/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun me/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun me/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

Disable documentation for object at point in the echo area. It conflicts with Flycheck.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :config (global-eldoc-mode -1))
#+END_SRC

Customize the noisy default towards backup files.

#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :custom
  (backup-by-copying t)
  (backup-directory-alist `(("." . ,(expand-file-name "backups/" user-emacs-directory))))
  (delete-old-versions t)
  (version-control t))
#+END_SRC

Add visual guides towards indenting levels.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook
  (python-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character))
#+END_SRC

Highlight line under point.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :ensure nil
  :preface (defun me/hl-line-mode-off () (setq-local global-hl-line-mode nil))
  :hook (after-init . global-hl-line-mode))
#+END_SRC

Originally, =midnight= is used to /run something at midnight/. I use its feature that
kills old buffers.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :ensure nil
  :custom
  (clean-buffer-list-delay-general 1)
  :config
  (add-to-list 'clean-buffer-list-kill-never-buffer-names "dotemacs.org"))
#+END_SRC

Augment Emacs' package menu.

#+BEGIN_QUOTE
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line
information. Github integration, customizability, asynchronous upgrading, and
more.

[[https://github.com/Malabarba/paradox][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :custom
  (paradox-column-width-package 27)
  (paradox-column-width-version 13)
  (paradox-execute-asynchronously t)
  (paradox-github-token t)
  (paradox-hide-wiki-packages t)
  :config
  (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+END_SRC

Prettify symbols. Below is the configuration of the prettify-symbol feature. You
should enable the feature as a minor-mode and on a per-mode basis only.

#+BEGIN_SRC emacs-lisp
(use-package prog-mode
  :ensure nil
  :preface
  (defun me/prettify-symbols-compose-predicate (&rest arguments)
    (when (not (eq system-type 'windows-nt))
      (apply #'prettify-symbols-default-compose-p arguments)))
  :custom
  (prettify-symbols-compose-predicate #'me/prettify-symbols-compose-predicate)
  (prettify-symbols-unprettify-at-point 'right-edge))
#+END_SRC

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook prog-mode
  :custom (rainbow-x-colors-major-mode-list '()))
#+END_SRC

Turn on =auto-fill-mode= /almost/ everywhere.

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :hook
  ((prog-mode . turn-on-auto-fill)
   (text-mode . turn-on-auto-fill)))
#+END_SRC

** Shell and Terminal

#+BEGIN_SRC emacs-lisp
(use-package em-hist
  :ensure nil
  :custom (eshell-hist-ignoredups t))

(use-package esh-mode
  :ensure nil
  :preface
  (defun me/eshell-bol-shifted ()
    "See `eshell-bol'. Support shift."
    (interactive "^")
    (eshell-bol))
  :bind
  (:map eshell-mode-map
        ([remap eshell-bol] . me/eshell-bol-shifted))
  :hook
  ((eshell-mode . me/hl-line-mode-off)
   (eshell-mode . (lambda () (setq-local scroll-margin 0))))
  :custom
  (eshell-scroll-to-bottom-on-input t))
#+END_SRC

Yes, Emacs emulates terminals too.

- **TODO**: Source =.bash_profile= on =M-x term=.

#+BEGIN_SRC emacs-lisp
(use-package term
  :ensure nil
  :hook
  ((term-mode . me/hl-line-mode-off)
   (term-mode . (lambda () (setq-local scroll-margin 0)))))
#+END_SRC

Provide a way to invoke =bash= on Windows. This requires "Developer Mode" to
be enabled in the first place.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (defun me/bash ()
    (interactive)
    (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
      (shell))))
#+END_SRC

** Version Control

Magit provides Git facilities directly from within Emacs.

#+BEGIN_QUOTE
Magit is an interface to the version control system
[[https://git-scm.com/][Git]], implemented as an
[[https://www.gnu.org/software/emacs][Emacs]] package. Magit aspires to be a
complete Git porcelain. While we cannot (yet) claim that Magit wraps and
improves upon each and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version control tasks
directly from within Emacs. While many fine Git clients exist, only Magit and
Git itself deserve to be called porcelains.
[[https://magit.vc/about.html][(more)]]

[[https://github.com/magit/magit][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :preface
  (defun me/git-commit-auto-fill-everywhere ()
    (setq fill-column 72)
    (setq-local comment-auto-fill-only-comments nil))
  :hook
  (git-commit-mode . me/git-commit-auto-fill-everywhere)
  :custom
  (git-commit-summary-max-length 50))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  (:map magit-hunk-section-map
        ("RET" . magit-diff-visit-file-other-window)
        ([return] . magit-diff-visit-file-other-window))
  :custom
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-body nil)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside magit-diff-highlight-hunk-region-using-face))
  (magit-popup-display-buffer-action '((display-buffer-same-window)))
  (magit-refs-show-commit-count 'all)
  (magit-section-show-child-count t)
  :config
  (remove-hook 'magit-section-highlight-hook #'magit-section-highlight))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+END_SRC

** Whitespaces

Highlight space-like characters, eg. trailing spaces, tabs, empty lines.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure nil
  :hook
  ((prog-mode . whitespace-turn-on)
   (text-mode . whitespace-turn-on))
  :custom
  (whitespace-style '(face empty indentation::space tab trailing)))
#+END_SRC

-----

[[#dotemacs][Back to to
* alu
** fixes

 Various fixes I've implemented.

 Fixing left and right arrows changed in newer emacs for helm

 #+BEGIN_SRC emacs-lisp
 (define-key helm-map (kbd "<left>") 'helm-previous-source)
 (define-key helm-map (kbd "<right>") 'helm-next-source)
 (customize-set-variable 'helm-ff-lynx-style-map t)
 (customize-set-variable 'helm-imenu-lynx-style-map t)
 (customize-set-variable 'helm-semantic-lynx-style-map t)
 (customize-set-variable 'helm-occur-use-ioccur-style-keys t)
 #+END_SRC

** keybindings

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f1>") 'helm-projectile-find-file)
(global-set-key (kbd "M-r") 'replace-string)
(global-set-key (kbd "<backspace>")
          '(lambda () (interactive) (backward-delete-char-untabify 1 nil)))
(global-set-key (kbd "C-c c") 'comment-or-uncomment-region)
(global-set-key (kbd "C-c i") 'helm-imenu)
(global-set-key (kbd "C-c .") 'semantic-ia-fast-jump)
#+END_SRC

** packages

Various packages I use

#+BEGIN_SRC emacs-lisp
(use-package cedet)
(use-package ws-butler)
(use-package bash-completion)
(use-package semantic)
(use-package ede-php-autoload)
(use-package php-mode
  :bind (:map php-mode-map ([remap c-set-style] . semantic-ia-fast-jump))
)
(use-package flycheck-phpstan)
(use-package undo-tree)
(global-undo-tree-mode)
#+END_SRC

** hooks

#+BEGIN_SRC emacs-lisp
(setq semantic-default-submodes
      '(;; Perform semantic actions during idle time
        global-semantic-idle-scheduler-mode
        ;; Use a database of parsed tags
        global-semanticdb-minor-mode
        ;; Decorate buffers with additional semantic information
        global-semantic-decoration-mode
        ;; Highlight the name of the function you're currently in
        global-semantic-highlight-func-mode
        ;; show the name of the function at the top in a sticky
        global-semantic-stickyfunc-mode
        ;; Generate a summary of the current tag when idle
        global-semantic-idle-summary-mode
        ;; Show a breadcrumb of location during idle time
        global-semantic-idle-breadcrumbs-mode
        ;; Show idle completions
        global-semantic-idle-completions-mode
        ;; Switch to recently changed tags with `semantic-mrub-switch-tags',
        ;; or `C-x B'
        global-semantic-mru-bookmark-mode))

(setq company-backends
      '((company-files          ; files & directory
         company-keywords       ; keywords
         company-dabbrev-code
         company-gtags
         company-etags
         company-capf
         company-yasnippet
         company-semantic
         )
        (company-abbrev company-dabbrev)
        ))

(defun alu-code-editing ()
  "Activate various minor-modes that are usefull when editing code"
  (interactive)
  (require 'flycheck-phpstan)
  (flycheck-mode t)
  (ede-php-autoload-mode)
  (ws-butler-mode 1)
  (semantic-mode 1))

(add-hook 'php-mode-hook #'alu-code-editing)
(add-hook 'python-mode-hook #'alu-code-editing)
#+END_SRC
